<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chauncy&#39;s Blog</title>
    <link>https://wcj98.github.io/</link>
    <description>Recent content on Chauncy&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Wed, 03 Jul 2019 20:05:52 +0800</lastBuildDate>
    
	<atom:link href="https://wcj98.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android学习笔记--软引用和弱引用</title>
      <link>https://wcj98.github.io/post/android_note_1/</link>
      <pubDate>Wed, 03 Jul 2019 20:05:52 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/android_note_1/</guid>
      <description>Android学习笔记&amp;ndash;软引用和弱引用 1.软引用
软引用是用来描述一些有用但并不是必需的对象，在内存严重不足的情况下会被系统回收，如果该对象可能会经常使用的， 就尽量用软引用。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 //创建一个对bitmap的弱引用 SoftReference&amp;lt;Bitmap&amp;gt; softReference = new SoftReference&amp;lt;Bitmap&amp;gt;(bitmap);//bitmap是一个Bitmap的实例。 //get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。 Bitmap bitmap = softReference.get();  2.弱引用
弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象， WeakReference 的强度又明显低于 SoftReference，所以如果该对象不被使用的可能性更大些，就可以用弱引用。 WeakReference&amp;lt;Bitmap&amp;gt; weakReference = new WeakReference&amp;lt;Bitmap&amp;gt;(bitmap1); Bitmap bitmap1 = weakReference.get();  #例：
private Map&amp;lt;String, SoftReference&amp;lt;Bitmap&amp;gt;&amp;gt; imageCache = new HashMap&amp;lt;String, SoftReference&amp;lt;Bitmap&amp;gt;&amp;gt;(); public void addBitmapToCache(String path) { // 强引用的Bitmap对象 Bitmap bitmap = BitmapFactory.decodeFile(path); // 软引用的Bitmap对象 SoftReference&amp;lt;Bitmap&amp;gt; softBitmap = new SoftReference&amp;lt;Bitmap&amp;gt;(bitmap); // 添加该对象到Map中使其缓存 imageCache.put(path, softBitmap); } public Bitmap getBitmapByPath(String path) { // 从缓存中取软引用的Bitmap对象 SoftReference&amp;lt;Bitmap&amp;gt; softBitmap = imageCache.</description>
    </item>
    
    <item>
      <title>Android的线程池</title>
      <link>https://wcj98.github.io/post/threadpool/</link>
      <pubDate>Tue, 02 Jul 2019 22:44:07 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/threadpool/</guid>
      <description>1.Java 线程池 Java通过Executors提供四种线程池，分别为：
(1).newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程 (2).newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待 (3).newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行 (4).newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺FIFO, LIFO, 优先执行  2.ThreadPoolExecutor 创建基本线程池 创建线程池，主要是利用ThreadPoolExecutor这个类，而这个类有几种构造方法，其中参数最多的一种构造方法如下： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory) { &amp;hellip; }
corePoolSize: 该线程池中核心线程的数量maximumPoolSize：该线程池中最大线程数量区别于corePoolSize) keepAliveTime:从字面上就可以理解，是非核心线程空闲时要等待下一个任务到来的时间，当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程unit:上面时间属性的单位 workQueue:任务队列，threadFactory:线程工厂，可用于设置线程名字等等，一般无须设置该参数设置好几个参数就可以创建一个基本的线程池，而之后的各种线程池都是在这种基本线程池的基础上延伸的  3.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下： ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
 for (int i = 0; i &amp;lt; 10; i++) { final int index = i; try { Thread.sleep(index * 1000); } catch (InterruptedException e) { e.printStackTrace(); } cachedThreadPool.</description>
    </item>
    
    <item>
      <title>Android的缓存工具</title>
      <link>https://wcj98.github.io/post/cacheutils/</link>
      <pubDate>Mon, 01 Jul 2019 22:46:45 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/cacheutils/</guid>
      <description>#DiskLruCache
注：需要将DiskLruCache的.jar包引入自己的工程。 //创建缓存目录 private static File getCacheDir(Context context, String fileName) { String cachePath = context.getCacheDir().getPath(); return new File(cachePath + File.separator, fileName); } public static DiskLruCache createDiskLruCache(Context context, String name) { DiskLruCache diskLruCache = null; File cacheDir = getCacheDir(context, name); if (!cacheDir.exists()) { cacheDir.mkdirs(); } try { diskLruCache = DiskLruCache.open(cacheDir, 1, 1, 10 * 1024 * 1024); } catch (IOException e) { e.printStackTrace(); } return diskLruCache; } //Url转MD5 private static String toHexMd5(String path) { String cacheKey = null; try { final MessageDigest mDigest = MessageDigest.</description>
    </item>
    
    <item>
      <title>Android的图片工具类</title>
      <link>https://wcj98.github.io/post/bitmaputils/</link>
      <pubDate>Sun, 30 Jun 2019 23:48:01 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/bitmaputils/</guid>
      <description>Android的主要用来处理图片的工具类 public static Bitmap decodeBitmap(byte[] b, int reqW, int reqH, boolean config) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(b, 0, b.length, options); options.inJustDecodeBounds = false; options.inSampleSize = editBitmap(options, reqW, reqH); if (config) { options.inPreferredConfig = Bitmap.Config.RGB_565; } return BitmapFactory.decodeByteArray(b, 0, b.length, options); } public static Bitmap decodeBitmap(Resources resources, int resId, int reqW, int reqH, boolean config) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(resources, resId, options); options.</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://wcj98.github.io/post/about/</link>
      <pubDate>Sun, 02 Jun 2019 21:32:24 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/about/</guid>
      <description>##博客说明 这个博客主要来记录，学习Android和Java的笔记和错误。
总结进步！！！</description>
    </item>
    
  </channel>
</rss>