<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Chauncy&#39;s Blog</title>
    <link>https://wcj98.github.io/post/</link>
    <description>Recent content in Posts on Chauncy&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sat, 03 Aug 2019 19:35:25 +0800</lastBuildDate>
    
	<atom:link href="https://wcj98.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ItemTouchHelper实现RecyclerView的拖拽和滑动删除</title>
      <link>https://wcj98.github.io/post/itemtouchhelper%E5%AE%9E%E7%8E%B0recyclerview%E7%9A%84%E6%8B%96%E6%8B%BD%E5%92%8C%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4/</link>
      <pubDate>Sat, 03 Aug 2019 19:35:25 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/itemtouchhelper%E5%AE%9E%E7%8E%B0recyclerview%E7%9A%84%E6%8B%96%E6%8B%BD%E5%92%8C%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4/</guid>
      <description>编写ItemTouchHelper实现RecyclerView的拖拽和滑动删除，遇到的问题。
 1.给RecyclerView设置分割线： RecyclerView.addItemDecoration(new RecyclerView.ItemDecoration() { @Override public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); outRect.set(5, 5, 5, 5); } }); 需要设置背景色，才能有效果。 2.拖拽ViewHolder想要实现阴影。 通过setElevation()方法，发现没有效果。 单单设置Z轴的偏移,itemView.setTranslationZ(20),也没有效果。 最后设置了 itemView.setBackgroundColor(Color.WHITE); itemView.setTranslationZ(0); 才有阴影效果。(不知道为什么) *****最后才发现在XML给itemView设置了Background会没有Z轴偏移的效果。  </description>
    </item>
    
    <item>
      <title>自定义View</title>
      <link>https://wcj98.github.io/post/%E8%87%AA%E5%AE%9A%E4%B9%89view/</link>
      <pubDate>Fri, 02 Aug 2019 09:34:01 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/%E8%87%AA%E5%AE%9A%E4%B9%89view/</guid>
      <description>自定义View和ViewGroup
一个View的生成需要经过测量、布局和绘制三步，分别对应View中的 onMeasure()、onLayout()和onDraw()方法。 1、MeasureSpec的作用 子View的onMeasure方法中会传来parentView的限制。 可以通过： int modeW = MeasureSpec.getMode(widthMeasureSpec); int sizeW = MeasureSpec.getSize(widthMeasureSpec); int modeH = MeasureSpec.getMode(heightMeasureSpec); int sizeH = MeasureSpec.getSize(heightMeasureSpec); 来获取尺寸和模式。 ①UNSPECIFIED：未指定模式，父容器不限制View的大小，一般用于系统内部的测量 ②AT_MOST：最大模式，对应于在xml文件中指定控件大小为wrap_content属性，子View的最终大小是父View指定的大小值，并且子View的大小不能大于这个值 ③EXACTLY ：精确模式，对应于在xml文件中指定控件为match_parent属性或者是具体的数值，父容器测量出View所需的具体大小 2.ViewGroup的自定义 (1)需要在其onMeasure方法中遍历所有的子View,调用方法来测量其子View的大小， measureChild(childView, widthMeasureSpec, heightMeasureSpec); 从而来确定自己的大小，同时还需要确定每个子View的位置， ViewGroup的onLayout方法，是对每个子View的位置进行进行摆放。 @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { for (int i = 0; i &amp;lt; getChildCount(); i++) { getChildAt(i).layout(childViewL.get(i), childViewT.get(i), childViewR.get(i), childViewB.get(i)); } } 3.自定义View的属性动画 例： ObjectAnimator animator = ObjectAnimator.ofInt(this, &amp;quot;degree&amp;quot;, 0, -90); 对一个自定义View的角度变化进行动画。 需要对该属性暴露出一个setter方法，并调用invalidate()，来实现重绘。 public void setDegree(int degree) { this.</description>
    </item>
    
    <item>
      <title>RecyclerView</title>
      <link>https://wcj98.github.io/post/recyclerview/</link>
      <pubDate>Sun, 21 Jul 2019 17:34:54 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/recyclerview/</guid>
      <description>关于RecyclerView的坑
1.下拉刷新需要重新设置new adapter和setadapter,不然数据不刷新 if (mDuanziRecyclerViewAdapter != null) mDuanziRecyclerViewAdapter = null; mDuanziRecyclerViewAdapter = new DuanziVideoAdapter((DuanziBean) msg.obj, listener); rv.setAdapter(mDuanziRecyclerViewAdapter); mDuanziRecyclerViewAdapter.notifyDataSetChanged(); 2.上拉刷新不能new adapter 和setadapter ，不然数据回到第一个数据 if (mDuanziRecyclerViewAdapter == null) { mDuanziRecyclerViewAdapter = new DuanziVideoAdapter((DuanziBean) msg.obj, listener); rv.setAdapter(mDuanziRecyclerViewAdapter); } mDuanziRecyclerViewAdapter.notifyDataSetChanged(); 3.瀑布流刷新一次数据需要重新设置一次 new staggeredGridLayoutManager，否则没有数据显示 if (staggeredGridLayoutManager == null) { staggeredGridLayoutManager = null; } staggeredGridLayoutManager = new StaggeredGridLayoutManager(2, RecyclerView.VERTICAL); rv.setLayoutManager(staggeredGridLayoutManager); rv.setAdapter(mDuanziRecyclerViewAdapter); mDuanziRecyclerViewAdapter.notifyDataSetChanged();  </description>
    </item>
    
    <item>
      <title>Android学习笔记--软引用和弱引用</title>
      <link>https://wcj98.github.io/post/android_note_1/</link>
      <pubDate>Wed, 03 Jul 2019 20:05:52 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/android_note_1/</guid>
      <description>Android学习笔记&amp;ndash;软引用和弱引用 1.软引用
软引用是用来描述一些有用但并不是必需的对象，在内存严重不足的情况下会被系统回收，如果该对象可能会经常使用的， 就尽量用软引用。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 //创建一个对bitmap的弱引用 SoftReference&amp;lt;Bitmap&amp;gt; softReference = new SoftReference&amp;lt;Bitmap&amp;gt;(bitmap);//bitmap是一个Bitmap的实例。 //get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。 Bitmap bitmap = softReference.get();  2.弱引用
弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象， WeakReference 的强度又明显低于 SoftReference，所以如果该对象不被使用的可能性更大些，就可以用弱引用。 WeakReference&amp;lt;Bitmap&amp;gt; weakReference = new WeakReference&amp;lt;Bitmap&amp;gt;(bitmap1); Bitmap bitmap1 = weakReference.get();  #例：
private Map&amp;lt;String, SoftReference&amp;lt;Bitmap&amp;gt;&amp;gt; imageCache = new HashMap&amp;lt;String, SoftReference&amp;lt;Bitmap&amp;gt;&amp;gt;(); public void addBitmapToCache(String path) { // 强引用的Bitmap对象 Bitmap bitmap = BitmapFactory.decodeFile(path); // 软引用的Bitmap对象 SoftReference&amp;lt;Bitmap&amp;gt; softBitmap = new SoftReference&amp;lt;Bitmap&amp;gt;(bitmap); // 添加该对象到Map中使其缓存 imageCache.put(path, softBitmap); } public Bitmap getBitmapByPath(String path) { // 从缓存中取软引用的Bitmap对象 SoftReference&amp;lt;Bitmap&amp;gt; softBitmap = imageCache.</description>
    </item>
    
    <item>
      <title>Android的线程池</title>
      <link>https://wcj98.github.io/post/threadpool/</link>
      <pubDate>Tue, 02 Jul 2019 22:44:07 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/threadpool/</guid>
      <description>1.Java 线程池 Java通过Executors提供四种线程池，分别为：
(1).newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程 (2).newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待 (3).newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行 (4).newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺FIFO, LIFO, 优先执行  2.ThreadPoolExecutor 创建基本线程池 创建线程池，主要是利用ThreadPoolExecutor这个类，而这个类有几种构造方法，其中参数最多的一种构造方法如下： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory) { &amp;hellip; }
corePoolSize: 该线程池中核心线程的数量maximumPoolSize：该线程池中最大线程数量区别于corePoolSize) keepAliveTime:从字面上就可以理解，是非核心线程空闲时要等待下一个任务到来的时间，当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程unit:上面时间属性的单位 workQueue:任务队列，threadFactory:线程工厂，可用于设置线程名字等等，一般无须设置该参数设置好几个参数就可以创建一个基本的线程池，而之后的各种线程池都是在这种基本线程池的基础上延伸的  3.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下： ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
 for (int i = 0; i &amp;lt; 10; i++) { final int index = i; try { Thread.sleep(index * 1000); } catch (InterruptedException e) { e.printStackTrace(); } cachedThreadPool.</description>
    </item>
    
    <item>
      <title>Android的缓存工具</title>
      <link>https://wcj98.github.io/post/cacheutils/</link>
      <pubDate>Mon, 01 Jul 2019 22:46:45 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/cacheutils/</guid>
      <description>#DiskLruCache
注：需要将DiskLruCache的.jar包引入自己的工程。 //创建缓存目录 private static File getCacheDir(Context context, String fileName) { String cachePath = context.getCacheDir().getPath(); return new File(cachePath + File.separator, fileName); } public static DiskLruCache createDiskLruCache(Context context, String name) { DiskLruCache diskLruCache = null; File cacheDir = getCacheDir(context, name); if (!cacheDir.exists()) { cacheDir.mkdirs(); } try { diskLruCache = DiskLruCache.open(cacheDir, 1, 1, 10 * 1024 * 1024); } catch (IOException e) { e.printStackTrace(); } return diskLruCache; } //Url转MD5 private static String toHexMd5(String path) { String cacheKey = null; try { final MessageDigest mDigest = MessageDigest.</description>
    </item>
    
    <item>
      <title>Android的图片工具类</title>
      <link>https://wcj98.github.io/post/bitmaputils/</link>
      <pubDate>Sun, 30 Jun 2019 23:48:01 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/bitmaputils/</guid>
      <description>Android的主要用来处理图片的工具类 public static Bitmap decodeBitmap(byte[] b, int reqW, int reqH, boolean config) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(b, 0, b.length, options); options.inJustDecodeBounds = false; options.inSampleSize = editBitmap(options, reqW, reqH); if (config) { options.inPreferredConfig = Bitmap.Config.RGB_565; } return BitmapFactory.decodeByteArray(b, 0, b.length, options); } public static Bitmap decodeBitmap(Resources resources, int resId, int reqW, int reqH, boolean config) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(resources, resId, options); options.</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://wcj98.github.io/post/about/</link>
      <pubDate>Sun, 02 Jun 2019 21:32:24 +0800</pubDate>
      
      <guid>https://wcj98.github.io/post/about/</guid>
      <description>##博客说明 这个博客主要来记录，学习Android和Java的笔记和错误。
总结进步！！！</description>
    </item>
    
  </channel>
</rss>